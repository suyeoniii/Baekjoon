/*
	문제 : k-1,k,k+1만큼 속도를 바꿔가며 도착지 까지 갈려고 할 때 최소한의 이동 수
	*첫속도와 마지막 속도는 항상 1임
	ex) 출발 : 1 , 도착 : 5
	속도 = 1, 2, 1
	답 = 3

	예시)

	입력 : 
	3 (테스트 케이스 수)
	0 3 (출발,도착지)
	1 5
	45 50

	출력 : (이동 수)
	3
	3
	4

	-updated 2020.08.22 suyeoniii
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
	int N, ans, length, k; //테스트 케이스 수, 답, 남은 길이, 이동 길이
	bool even; //k를 더하는 횟수의 짝/홀 수 판별

	vector <int> v;
	
	cin >> N;

	for (int i = 0; i < N; i++) { //입력
		int a, b;
		cin >> a;
		cin >> b;
		v.push_back(b - a); //거리로 저장
	}

	for (int i = 0; i < N; i++) {

		ans = 0;
		length = v[i]; //남은 길이 = 거리
		even = false; //초기값 = 홀수번
		k = 1; 

			while (length > 0) { //길이가 0보다 큰 동안 진행
				length -= k; //k만큼 길이를 빼주고 답++
				ans += 1;

				if (even) { //k를 두번 더했으면, 1늘려줌
					k = k + 1;
					even = false;
				}
				else { //k 한번 더했음
					even = true;
				}
			}
		cout << ans << endl;
	}
}

/*
알고리즘
처음 시작, 끝 길이가 1, 1이므로
1
11
121
1221
12321
123321
1234321
...
이 진행이 각 길이의 최댓값임(12321 = 5번)
가야하는 거리를 보고, k를 1부터 늘려가면서 빼줌
남은 길이가 0이거나 음수가 되면 종료하고 출력

Q. 왜 음수가 되었는데도 그대로 출력하는게 답일까?
5번 가는 경우는 12321이 최댓 값이지만
12221, 12121의 경우 등이 가능함, 하지만 이 경우들은 4번 이동의 최댓값보단 커서 4번이동은 안되고
5번 이동해야 얻을 수 있는 값임
따라서, k-1의 최댓값<길이<k의 최댓값 일 때 k번 가는 것이 답이 됨
*/
